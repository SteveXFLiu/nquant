---
title: "**Vectorization in Python**"
author: Steve Leo
date: today

format:
  pdf:
    documentclass: article
    geometry:
        - a4paper
        - margin=1in 
    toc: false
    number-sections: true
    colorlinks: true

pdf-engine: xelatex

highlight-style: ayu
code-block-bg: true
code-block-border-left: "#31BAE9"

include-in-header: 
      text: |
        \usepackage{fontspec}
        \usepackage{xunicode}
        \usepackage{xltxtra}
        \usepackage{fvextra}

        \setmainfont{Miller Text}
        \setmonofont{Hack Nerd Font Mono}

        \DefineVerbatimEnvironment{Highlighting}{Verbatim}{
          commandchars=\\\{\},
          breaklines, breaknonspaceingroup, breakanywhere
        }
---

# Introduction
Vectorization, or array programming, is a programming style in which operations on scalars are generalized to vectors, matrices, or even multidimensional arrays. Suppose $a$, $b$, $c$ are scalars, and $\mathbf{v}$ is a matrix:
$$
\mathbf{v} =
\begin{pmatrix}
v_{11} & v_{12} & \cdots & v_{1n}
\\
v_{21} & v_{22} & \cdots & v_{2n}
\\
\vdots & \vdots & \ddots & \vdots
\\
v_{m1} & v_{m2} & \cdots & v_{mn}
\end{pmatrix}
= 
\begin{pmatrix}
v_{ij}
\end{pmatrix}
_{mn}
$$
Then vectorization means:
$$
\begin{aligned}
a\mathbf{v} + b &= 
\begin{pmatrix}
av_{ij} + b
\end{pmatrix}
_{mn}
\\
\mathbf{v}^c &= 
\begin{pmatrix}
{v_{ij}}^c
\end{pmatrix}
_{mn}
\end{aligned}
$$
Or more generally, 
$$
f\left(\mathbf{v}\right) = \left(f\left(v_{ij}\right)\right)_{mn}
$$

But the standard instruciton set and data model of pure Python does not generally allow for vectorization:
```{python}
v = [1, 2, 3]

2 * v
```
In pure Python, we need loops to complete the computation:
```{python}
v2 = [2 * i for i in v]

v2
```

We need Python packages `NumPy` and `pandas` to implement vectorization, quickly and conviently.
```{python}
import numpy as np
import pandas as pd
```

We also use `yfinance` package to download some data:
```{python}
import yfinance as yf
```

To plot some data, we define the style of our plottings:
```{python}
import matplotlib.pyplot as plt

# Set plt style
plt.rcParams['font.family'] = 'Palatino'
plt.rcParams['font.size'] = 8
plt.rcParams['axes.labelsize'] = 8
plt.rcParams['xtick.labelsize'] = 8
plt.rcParams['ytick.labelsize'] = 8
plt.rcParams['lines.linewidth'] = 1
plt.rcParams["axes.xmargin"] = 0
```

# Vectorization with `NumPy`
The `ndarray` class of `NumPy` supports vectorization as desired:
```{python}
arr = np.array(v)

2 * arr
```

```{python}
0.5 * arr + 1 
```

```{python}
arr ** 2
```

Vectorization of boolean judgements are also supported:
```{python}
bl = np.array([0, 1, 2, 3, 0])

bl > 0
```

The `ndarray` class also provides specific methods and functions that allow vectorized operations:
```{python}
mat = np.arange(12).reshape((4, 3))

mat
```

```{python}
mat.mean()
```

```{python}
mat.mean(axis=0)
```

```{python}
np.mean(mat, axis=1)
```

# Vectorization with `pandas`
The `DataFrame` class of `pandas` also supports vectorization well:
```{python}
#| warning: false
#| label: tbl-index-returns
#| tbl-cap: "Daily Returns of 3 Stock Indexes in June, 2025"

tickers = ["^GSPC", "^DJI", "^IXIC"]
indexes = {
  "^GSPC": "SP500",
  "^DJI": "DJ30",
  "^IXIC": "NSDQ"
}

df = yf.download(tickers, start="2025-05-30", end="2025-06-30", progress=False)

rtn = df["Close"].pct_change().dropna().rename(columns=indexes)

rtn
```

```{python}
rtn.mean()
```

```{python}
#| warning: false
#| label: tbl-index-return-special
#| tbl-cap: "Days with Returns of DJ30 and SP500 Are Both Better Than NSDQ in June, 2025"
rtn[(rtn["DJ30"] > rtn["NSDQ"]) & (rtn["SP500"] > rtn["NSDQ"])]
```

# Applications in Backtestings
## Strategies Based on Simple Moving Averages
Simple moving averages (SMAs) can be obtained with the `rolling()` and `mean()` methods.We use the SP500 index as an example:
```{python}
#| warning: false
#| label: tbl-sp500-sma
#| tbl-cap: "Daily Close Prices and SMAs of SP500 Index (2015-2025)"

sp500 = yf.Ticker("^GSPC")
raw = sp500.history(start="2014-09-30", end="2025-06-30")

raw["SMA20"] = raw["Close"].rolling(20).mean()
raw["SMA60"] = raw["Close"].rolling(60).mean()
raw["SMA180"] = raw["Close"].rolling(180).mean()

data = raw[["Close", "SMA20", "SMA60", "SMA180"]]["2014-12-31":].dropna()

data.round(2)
```

```{python}
#| warning: false
#| label: fig-sp500-sma
#| fig-cap: "Daily Close Prices and SMAs of SP500 Index (2015-2025)"

data.plot()
```