---
title: "**Manuplating Multindex DataFrames**"
author: Steve Leo
date: today

format:
  pdf:
    documentclass: article
    geometry:
        - a4paper
        - margin=1in 
    toc: false
    number-sections: true
    colorlinks: true

pdf-engine: xelatex

highlight-style: ayu
code-block-bg: true
code-block-border-left: "#31BAE9"

include-in-header: 
      text: |
        \usepackage{fontspec}
        \usepackage{xunicode}
        \usepackage{xltxtra}
        \usepackage{fvextra}

        \setmainfont[Scale=0.85]{Miller Text}
        \setmonofont{Hack Nerd Font Mono}

        \DefineVerbatimEnvironment{Highlighting}{Verbatim}{
          commandchars=\\\{\},
          breaklines, breaknonspaceingroup, breakanywhere
        }
---

# Introduction
When we download price series of multiple stocks, we usually obtain a multindex DataFrame. For example, use `yfinance.download()` to get the daily prices of NVDA and TSLA in 2024:

```{python}
import yfinance as yf
import pandas as pd
```

```{python}
#| warning: False
#| label: tbl-multindx-by-column
#| tbl-cap: "A Multindex DataFrame Grouped by Price Types"

tickers = ['NVDA', 'TSLA']

df1 = yf.download(tickers, start="2023-12-29", end="2024-12-31", progress=False)

df1.round(2)
```

This DataFrame is called *multindex* because each column has *two* indexes, the price type (Open/High/Low/Close/Volume) and the stock ticker (NVDA/TSLA). Actually, each column is indexed by a combination of these two indeces. The first column (the second column in @tbl-multindx-by-column) is indexed by Close and NVDA, the second column is indexed by Close and TSLA, and so on:
```{python}
df1.columns
```
The complete header of @tbl-multindx-by-column should be:

| Price Ticker | Close NVDA | Close TSLA | High NVDA | High TSLA | Low NVDA | Low TSLA | Open NVDA | Open TSLA | Volume NVDA | Volume TSLA |
|--------------|:----------:|:----------:|:---------:|:---------:|:--------:|:--------:|:---------:|:---------:|:-----------:|:-----------:|
| Date         |            |            |           |           |          |          |           |           |             |             |

It is helpful to understand this multindex DataFrame further if we generate a similar one manually:

```{python}
#| warning: false
#| label: tbl-multindx-generated
#| tbl-cap: "A Generated Multindex DataFrame"

data = {
    ('Close', 'NVDA'): [7.00, 8.00, 9.00],
    ('Close', 'TSLA'): [6.00, 7.00, 8.00],
    ('Open', 'NVDA'): [2.00, 3.00, 4.00],
    ('Open', 'TSLA'): [1.00, 2.00, 3.00]
}

date = pd.to_datetime(['2024-01-01', '2024-01-02', '2024-01-03'])

exam = pd.DataFrame(data)
exam.columns.names = ['Price', 'Ticker']

exam.index = date
exam.index.name = 'Date'

exam
```

The order of these two indexes is obviously not irrelevant. There is a parameter `group_by` in `yfinance.download()` to set the index order. By default, `group_by='column'` makes the price type first and the stock ticker second, as the above example. To obtain a dataframe with the stock ticker as the first index, set `group_by='ticker'`:

```{python}
#| warning: False
#| label: tbl-multindx-by-ticker
#| tbl-cap: "A Multindex DataFrame Grouped by Stock Tickers"

df2 = yf.download(tickers, start="2023-12-29", end="2024-12-31", progress=False, group_by='ticker')

df2.round(2)
```

The only difference is the order of the two indexes:

```{python}
df2.columns
```

Now we need to convert these multindex Dataframes to usual forms to perform further computations and statistics.

# Accessing Columns
The full index leads to the specific column. We can extract it as a Series:

```{python}
nvda_close = df1[('Close', 'NVDA')]

nvda_close
```

It is convenient to convert it to a DataFrame:
